.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::SVMLoc 3pm"
.TH Bio::Tools::SVMLoc 3pm "2013-04-04" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Tools::SVMLoc \- Perl implementation of the SVM based protein subcellular
localization method.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Bio::Tools::SVMLoc;
\&  use Bio::SeqIO;
\&
\&  # Load a previously trained model from a file.
\&  $svmloc = new Bio::Tools::SVMLoc(\-model  => \*(Aqsvmloc.model\*(Aq);
\&
\&  # Classify a Bio::Seq object.
\&  $loc = $svmloc\->classify($seq);
\&
\&  # Train SVMLoc on a new dataset.
\&  $accuracy = $svmloc\->train(\e@vectors, $localization, 
\&                             { Kernel  => \*(Aqlinear\*(Aq,
\&                               Optimize => 1 });
\&
\&  # Save the model to a file.
\&  $svmloc\->save(\*(Aqsvmloc.model.new\*(Aq);
\&
\&  # Load a model from a file.
\&  $svmloc\->load(\*(Aqsvmloc.model.new\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::Tools::SVMloc is an implementation of the SVMLoc protein subcellular
localization method, which predicts localizations based on amino acid
composition.  The method was originally outlined in \*(L"Support Vector
Machine Approach for Protein Subcellular Localization Prediction\*(R" paper by
Sujun Hua and Zhirong Sun.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.Vb 1
\&   $svmloc = new Bio::Tools::SVMLoc(\-model  => \*(Aqsvmloc.model\*(Aq);
.Ve
.PP
The SVMLoc constructor accepts the name of an existing model file.
.SH "METHODS"
.IX Header "METHODS"
.Vb 1
\&   $loc = $sl\->classify($seq, \e@frequent_patterns);
.Ve
.PP
The classify method accepts a Bio::Seq object and an array reference of
the known frequent patterns as arguments and returns a string containing
the predicted localization of the protein.  The return value will be one
of: Cytoplasmic, CytoplasmicMembrane, Periplasmic, OuterMembrane, Secreted,
Mitochondrial, Nuclear or Unknown.
.PP
.Vb 3
\&  $accuracy = $svmloc\->train(\e@vectors, $localization, 
\&                             { Kernel  => \*(Aqlinear\*(Aq,
\&                               Optimize => 1 });
.Ve
.PP
The train method allows the creation of a new \s-1SVM\s0 model based on a
set of user defined sequences.  The first parameter an array reference
containing the list of vectors to train the \s-1SVM\s0 on, those in the 
positive set will be prefixed by 1 while those in the negative set
will be prefixed by \-1.  The second parameter is a string containing
the localization that is being targeted with this \s-1SVM\s0.
.PP
The resulting model is unlikely to provide optimal results without some
degree of fine tuning to the underlying Support Vector Machine.  The
third (optional) parameter to the train method is a hashref which allows
one to pass options directly to the \s-1SVM\s0.  The set of valid keys are as
follows:
.PP
.Vb 2
\&  Kernel     \- The Support Vector Machine kernel to use, possible values
\&               are linear, polynomial, radial, and sigmoid.
\&  
\&  Optimize   \- If true, the module will attempt to search for the best
\&               values of the gamma and C parameters passed to the SVM.
\&               For any new model, this should be run at least once.
\&
\&               By default, the SVMLoc module will try all values for gamma
\&               between 1 and 100 (increments of 1) and C between 1 and 50
\&              (increments of one) until the optimal values of each are
\&               located.
\&
\&               Note that this **WILL** take quite some time, but only
\&               needs to be done once per model.  The model should be
\&               saved with the save method after training so that all
\&               optimal parameter values will be retained.
\&
\&  GammaStart \- Allows specification of the start value when searching for
\&               the optimal gamma value.  (Default 1)
\&
\&  GammaEnd   \- Allows specification of the end value when searching for
\&               the optimal gamma value.  (Default 100)
\&
\&  GammaInc   \- Allows specification of the size of the increment when
\&               searching for the optimal gamma value.  (Default 1)
\&
\&  CStart      \- Allows specification of the start value when searching for
\&               the optimal C value.  (Default 1)
\&
\&  CEnd        \- Allows specification of the end value when searching for
\&                the optimal C value.  (Default 50)
\&
\&  CInc        \- Allows specification of the size of the increment when
\&                searching for the optimal C value.  (Default 1)
\&
\&  $svmloc\->save(\*(Aqsvmloc.model.new\*(Aq);
.Ve
.PP
Saves the currently loaded model to the specified file.  Returns true on
success, false on failure.
.PP
.Vb 1
\&  $svmloc\->load(\*(Aqsvmloc.model.new\*(Aq);
.Ve
.PP
Loads an existing model from file.  Returns true on success, false on
failure.
.SH "AUTHOR"
.IX Header "AUTHOR"
Fiona Brinkman, Cory Spencer, Brinkman Lab, Simon Fraser University <psort\-mail@sfu.ca>
.SH "MAINTAINER"
.IX Header "MAINTAINER"
Matthew Laird <lairdm@sfu.ca>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Algorithm::SVM and the original SVMLoc paper titled \*(L"Support Vector Machine
Approach for Protein Subcellular Localization Prediction\*(R" by
Sujun Hua and Zhirong Sun
.SH "ACKNOWLEGEMENTS"
.IX Header "ACKNOWLEGEMENTS"
Chih-Jen Lin, one of the authors of the libsvm package upon which
Algorithm::SVM was based, was invaluable in creating this version of SVMLoc
Thanks also to Sujun Hua and Zhirong Sun, the authors of the original SVMLoc.
Last but not least, thanks to Fiona Brinkman, Jennifer Gardy and the other
members of the Simon Fraser University Brinkman laboratory.
